--#SET TERMINATOR @

/*
Copyright (c) 2014-2014 Andres Gomez Casanova (AngocA).

All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html -->

Contributors:
Andres Gomez Casanova - initial API and implementation.
*/

SET CURRENT SCHEMA DB2UNIT_1A @

/**
 * Asserts implementation.
 *
 * Version: 2014-05-02 1-Alpha
 * Author: Andres Gomez Casanova (AngocA)
 * Made in COLOMBIA.
 */

/**
 * Max size for assertion messages.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE MESSAGE_OVERHEAD SMALLINT CONSTANT 50 @

/**
 * Size of the chunk of a truncated string.
 */
ALTER MODULE DB2UNIT ADD
  VARIABLE MESSAGE_CHUNK SMALLINT CONSTANT 100 @

/**
 * Processes the given message.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION PROC_MESSAGE(
  IN MESSAGE ANCHOR DB2UNIT_1A.MAX_VALUES.MESSAGE_ASSERT
  ) RETURNS ANCHOR DB2UNIT_1A.MAX_VALUES.MESSAGE_ASSERT
  LANGUAGE SQL
  SPECIFIC F_PROC_MESSAGE
  DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 F_PROC_MESSAGE: BEGIN
  IF (MESSAGE = '') THEN
   SET MESSAGE = NULL;
  END IF;
  SET MESSAGE = COALESCE(MESSAGE || '. ', '');
  RETURN MESSAGE;
 END F_PROC_MESSAGE @

/**
 * Returns a character representation of the given boolean.
 *
 * IN VALUE
 *   Value to convert.
 * RETURN
 *   The corresponding represtation of the given boolean.
 */
ALTER MODULE DB2UNIT ADD
  FUNCTION BOOL_TO_CHAR(
  IN VALUE BOOLEAN
  ) RETURNS CHAR(5)
  LANGUAGE SQL
  SPECIFIC F_BOOL_TO_CHAR
  DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 F_BOOL_TO_CHAR: BEGIN
  DECLARE RET CHAR(5) DEFAULT 'FALSE';

  IF (VALUE IS NULL) THEN
    SET RET = 'NULL';
  ELSEIF (VALUE = TRUE) THEN
   SET RET = 'TRUE';
  END IF;
  RETURN RET;
 END F_BOOL_TO_CHAR @

/**
 * Asserts if the given two strings are the same, in nullability, in length and
 * in content.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN EXPECTED_STRING
 *   Expected string.
 * IN ACTUAL_STRING
 *   Actual string.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_EQUALS (
  IN MESSAGE ANCHOR DB2UNIT_1A.MAX_VALUES.MESSAGE_ASSERT,
  IN EXPECTED_STRING ANCHOR DB2UNIT_1A.MAX_STRING.STRING,
  IN ACTUAL_STRING ANCHOR DB2UNIT_1A.MAX_STRING.STRING
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_EQUALS_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_ASSERT_EQUALS_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;
  DECLARE SHOW BOOLEAN DEFAULT FALSE;
  DECLARE LENGTH SMALLINT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1A.DB2UNIT.P_ASSERT_EQUALS_MESSAGE',
    LOGGER_ID);
  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, EXPECTED_STRING);
  CALL LOGGER.DEBUG(LOGGER_ID, ACTUAL_STRING);

  -- Check values.
  IF ((EXPECTED_STRING IS NULL AND ACTUAL_STRING IS NOT NULL)
    OR (EXPECTED_STRING IS NOT NULL AND ACTUAL_STRING IS NULL)) THEN
   CALL WRITE_IN_REPORT (MESSAGE || 'Nullability difference');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
  ELSEIF (LENGTH(EXPECTED_STRING) <> LENGTH(ACTUAL_STRING)) THEN
   CALL WRITE_IN_REPORT (MESSAGE || 'Strings have different lengths');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
  ELSEIF (EXPECTED_STRING <> ACTUAL_STRING) THEN
   CALL WRITE_IN_REPORT (MESSAGE || 'The content of both strings is different');
   SET SHOW = TRUE;
   SET TEST_RESULT = RESULT_FAILED;
  END IF;

  -- Show problems.
  IF (SHOW = TRUE) THEN
   IF (EXPECTED_STRING IS NOT NULL) THEN
    SET LENGTH = LENGTH(EXPECTED_STRING);
    IF (LENGTH < MAX_MESSAGE - MESSAGE_OVERHEAD) THEN
     CALL WRITE_IN_REPORT ('Expected      : "' || EXPECTED_STRING || '"');
    ELSE
     SET EXPECTED_STRING = SUBSTR(EXPECTED_STRING, 1, MESSAGE_CHUNK) || '"..."'
       || SUBSTR(EXPECTED_STRING, LENGTH - MESSAGE_CHUNK);
     CALL WRITE_IN_REPORT ('Expd truncated: "' || EXPECTED_STRING || '"');
    END IF;
   ELSE
    CALL WRITE_IN_REPORT ('Expected      : NULL');
   END IF;
   IF (ACTUAL_STRING IS NOT NULL) THEN
    SET LENGTH = LENGTH(ACTUAL_STRING);
    IF (LENGTH < MAX_MESSAGE - MESSAGE_OVERHEAD) THEN
     CALL WRITE_IN_REPORT ('Actual        : "' || ACTUAL_STRING || '"');
    ELSE
     SET ACTUAL_STRING = SUBSTR(ACTUAL_STRING, 1, MESSAGE_CHUNK) || '"..."'
       || SUBSTR(ACTUAL_STRING, LENGTH - MESSAGE_CHUNK);
     CALL WRITE_IN_REPORT ('Actl truncated: "' || ACTUAL_STRING || '"');
    END IF;
   ELSE
    CALL WRITE_IN_REPORT ('Actual        : NULL');
   END IF;
  END IF;
 END P_ASSERT_EQUALS_MESSAGE @

/**
 * Asserts if the given value is true.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN CONDITION
 *   Value to check against TRUE.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_TRUE (
  IN MESSAGE ANCHOR DB2UNIT_1A.MAX_VALUES.MESSAGE_ASSERT,
  IN CONDITION BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_TRUE_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_ASSERT_TRUE_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1A.DB2UNIT.P_ASSERT_TRUE_MESSAGE', LOGGER_ID);
  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, BOOL_TO_CHAR(CONDITION));

  -- Check values.
  IF (CONDITION = FALSE) THEN
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "FALSE"');
   SET TEST_RESULT = RESULT_FAILED;
  END IF;
 END P_ASSERT_TRUE_MESSAGE @

/**
 * Asserts if the given value is false.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN CONDITION
 *   Value to check against FALSE.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_FALSE (
  IN MESSAGE ANCHOR DB2UNIT_1A.MAX_VALUES.MESSAGE_ASSERT,
  IN CONDITION BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_FALSE_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_ASSERT_FALSE_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1A.DB2UNIT.P_ASSERT_FALSE_MESSAGE',
    LOGGER_ID);
  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, BOOL_TO_CHAR(CONDITION));

  -- Check values.
  IF (CONDITION = TRUE) THEN
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "TRUE"');
   SET TEST_RESULT = RESULT_FAILED;
  END IF;
 END P_ASSERT_FALSE_MESSAGE @

/**
 * Asserts if the given boolean is null.
 *
 * IN MESSAGE
 *   Related message to the test.
 * IN CONDITION
 *   Value to check if it is null.
 */
ALTER MODULE DB2UNIT ADD
  PROCEDURE ASSERT_NULL (
  IN MESSAGE ANCHOR DB2UNIT_1A.MAX_VALUES.MESSAGE_ASSERT,
  IN CONDITION BOOLEAN
  )
  LANGUAGE SQL
  SPECIFIC P_ASSERT_NULL_MESSAGE
  DYNAMIC RESULT SETS 0
  MODIFIES SQL DATA
  NOT DETERMINISTIC
  NO EXTERNAL ACTION
  PARAMETER CCSID UNICODE
 P_ASSERT_NULL_MESSAGE: BEGIN
  DECLARE LOGGER_ID SMALLINT;

  CALL LOGGER.GET_LOGGER('DB2UNIT_1A.DB2UNIT.P_ASSERT_NULL_MESSAGE', LOGGER_ID);
  -- Pre process
  SET MESSAGE = PROC_MESSAGE(MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, MESSAGE);
  CALL LOGGER.DEBUG(LOGGER_ID, BOOL_TO_CHAR(CONDITION));

  -- Check values.
  IF (CONDITION IS NOT NULL) THEN
   CALL WRITE_IN_REPORT (MESSAGE || 'The given value is "NOT NULL"');
   SET TEST_RESULT = RESULT_FAILED;
  END IF;
 END P_ASSERT_NULL_MESSAGE @

